<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√¥ ph·ªèng V·∫≠n d·ª•ng 2: L∆∞u v·∫øt ƒëo ƒë·∫°c</title>
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --wood-color: #8B4513;
            --primary: #007bff;
            --warning: #ffc107;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: #f4f4f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 { color: var(--wood-color); margin-bottom: 10px; }
        
        .main-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            max-width: 900px;
            width: 100%;
        }

        .window-area {
            flex: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            border-right: 1px dashed #ccc;
            padding-right: 20px;
        }

        canvas {
            background: #fafafa;
            border: 1px solid #ddd;
            cursor: pointer;
            border-radius: 8px;
        }

        .tools-area {
            flex: 1;
            min-width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-panel {
            background: #eee;
            padding: 15px;
            border-radius: 10px;
        }

        .tool-btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            background: white;
            border: 2px solid #ddd;
            font-weight: bold;
            transition: 0.2s;
        }

        .tool-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .status-box {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            border-left: 5px solid var(--warning);
            max-height: 200px;
            overflow-y: auto;
        }

        .log-item {
            padding: 5px;
            border-bottom: 1px solid #eee;
            font-size: 0.9rem;
        }

        .switch-container {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        #final-result {
            display: none;
            padding: 15px;
            margin-top: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            animation: popIn 0.5s;
        }

        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>

    <h1>Ki·ªÉm tra C·ª≠a S·ªï (L∆∞u v·∫øt ƒëo)</h1>

    <div class="main-container">
        <div class="window-area">
            <div class="switch-container">
                <label><input type="radio" name="doorState" value="rect" checked onchange="setDoorState('rect')"> C·ª≠a Vu√¥ng (Chu·∫©n)</label>
                <label><input type="radio" name="doorState" value="skew" onchange="setDoorState('skew')"> C·ª≠a L·ªách (H√¨nh b√¨nh h√†nh)</label>
            </div>
            <canvas id="mainCanvas" width="500" height="350"></canvas>
            <p style="font-size: 0.85rem; color: #666; margin-top:5px;">Click v√†o ƒê·ªânh (ƒëo g√≥c) ho·∫∑c n·ªëi 2 ƒê·ªânh (ƒëo ch√©o)</p>
        </div>

        <div class="tools-area">
            <div class="control-panel">
                <button class="tool-btn active" id="btnEke" onclick="selectTool('eke')">üìê D√πng √äke</button>
                <button class="tool-btn" id="btnString" onclick="selectTool('string')">üß∂ D√πng D√¢y</button>
                <button class="tool-btn" onclick="fullReset()" style="color: #dc3545; border-color: #dc3545;">üóëÔ∏è X√≥a h·∫øt l√†m l·∫°i</button>
            </div>

            <div class="status-box">
                <div id="instructionText" style="font-weight: bold; margin-bottom: 5px;">Ch·ªçn c√¥ng c·ª• ƒë·ªÉ b·∫Øt ƒë·∫ßu.</div>
                <div id="log"></div>
            </div>
            
            <div id="final-result"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const logEl = document.getElementById('log');
        const instructionEl = document.getElementById('instructionText');
        const finalResultEl = document.getElementById('final-result');

        // D·ªØ li·ªáu h√¨nh h·ªçc
        const basePoints = {
            A: { x: 100, y: 50 },
            B: { x: 100, y: 250 },
            C: { x: 400, y: 250 },
            D: { x: 400, y: 50 }
        };

        let currentPoints = JSON.parse(JSON.stringify(basePoints));
        let isSkewed = false;
        let currentTool = 'eke'; 
        
        // --- QU·∫¢N L√ù TR·∫†NG TH√ÅI ƒêO (ƒê·ªÇ L∆ØU H√åNH) ---
        let measuredCorners = []; // L∆∞u c√°c g√≥c ƒë√£ ƒëo: ['A', 'C']
        let measuredLines = [];   // L∆∞u c√°c d√¢y ƒë√£ ƒëo: [{p1:'A', p2:'C', dist: 360}, ...]
        let selectedPoints = [];  // ƒêi·ªÉm ƒëang ch·ªçn t·∫°m th·ªùi cho d√¢y

        // --- C·∫§U H√åNH & KH·ªûI T·∫†O ---
        function setDoorState(state) {
            isSkewed = (state === 'skew');
            fullReset(); // ƒê·ªïi tr·∫°ng th√°i c·ª≠a th√¨ reset ƒëo ƒë·∫°c
            
            if (isSkewed) {
                currentPoints.A.x = 150; currentPoints.D.x = 450; // K√©o l·ªách
                currentPoints.B.x = 100; currentPoints.C.x = 400;
            } else {
                currentPoints = JSON.parse(JSON.stringify(basePoints));
            }
            drawScene();
        }

        function selectTool(tool) {
            currentTool = tool;
            // X√≥a ƒëo ƒë·∫°c c·ªßa c√¥ng c·ª• kia ƒë·ªÉ ƒë·ª° r·ªëi m·∫Øt (ho·∫∑c gi·ªØ l·∫°i t√πy √Ω, ·ªü ƒë√¢y ch·ªçn x√≥a cho s·∫°ch)
            if (tool === 'eke') {
                measuredLines = []; 
                instructionEl.textContent = "ƒêang d√πng √äke: Click ƒë·ªÉ ki·ªÉm tra g√≥c vu√¥ng. H√¨nh ·∫£nh √äke s·∫Ω ƒë∆∞·ª£c gi·ªØ l·∫°i.";
            } else {
                measuredCorners = [];
                instructionEl.textContent = "ƒêang d√πng D√¢y: N·ªëi 2 ƒëi·ªÉm ƒë·ªëi di·ªán. D√¢y s·∫Ω ƒë∆∞·ª£c gi·ªØ l·∫°i ƒë·ªÉ so s√°nh.";
            }
            
            selectedPoints = [];
            finalResultEl.style.display = 'none';
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(tool === 'eke' ? 'btnEke' : 'btnString').classList.add('active');
            drawScene();
        }

        function fullReset() {
            measuredCorners = [];
            measuredLines = [];
            selectedPoints = [];
            logEl.innerHTML = '';
            finalResultEl.style.display = 'none';
            drawScene();
        }

        // --- H√ÄM V·∫º (RENDER) ---
        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. V·∫Ω khung c·ª≠a
            ctx.beginPath();
            ctx.moveTo(currentPoints.A.x, currentPoints.A.y);
            ctx.lineTo(currentPoints.B.x, currentPoints.B.y);
            ctx.lineTo(currentPoints.C.x, currentPoints.C.y);
            ctx.lineTo(currentPoints.D.x, currentPoints.D.y);
            ctx.closePath();
            ctx.lineWidth = 10;
            ctx.strokeStyle = '#8B4513';
            ctx.stroke();
            ctx.fillStyle = 'rgba(174, 217, 224, 0.3)';
            ctx.fill();

            // 2. V·∫Ω song c·ª≠a
            drawBars();

            // 3. V·∫º C√ÅC ƒêO ƒê·∫†C ƒê√É L∆ØU (QUAN TR·ªåNG)
            
            // V·∫Ω c√°c d√¢y ƒë√£ ƒëo
            measuredLines.forEach(line => {
                const p1 = currentPoints[line.p1];
                const p2 = currentPoints[line.p2];
                
                // D√¢y
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#6f42c1'; // T√≠m
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // S·ªë ƒëo
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                ctx.fillStyle = 'white';
                ctx.fillRect(midX - 25, midY - 10, 50, 20); // N·ªÅn tr·∫Øng cho ch·ªØ
                ctx.fillStyle = '#6f42c1';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(line.dist, midX, midY + 5);
            });

            // V·∫Ω c√°c √äke ƒë√£ ƒëo
            measuredCorners.forEach(corner => {
                drawVisualEke(corner);
            });

            // 4. V·∫Ω ƒëi·ªÉm g√≥c (Hotspots)
            ['A', 'B', 'C', 'D'].forEach(label => {
                const p = currentPoints[label];
                ctx.beginPath();
                ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = (selectedPoints.includes(label)) ? 'red' : '#333';
                ctx.fill();
                ctx.font = "bold 16px Arial";
                ctx.fillStyle = "black";
                ctx.textAlign = 'right';
                ctx.fillText(label, p.x - 12, p.y - 12);
            });
        }

        function drawBars() {
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#A0522D';
            const midAB = { x: (currentPoints.A.x + currentPoints.B.x)/2, y: (currentPoints.A.y + currentPoints.B.y)/2 };
            const midCD = { x: (currentPoints.D.x + currentPoints.C.x)/2, y: (currentPoints.D.y + currentPoints.C.y)/2 };
            const midAD = { x: (currentPoints.A.x + currentPoints.D.x)/2, y: (currentPoints.A.y + currentPoints.D.y)/2 };
            const midBC = { x: (currentPoints.B.x + currentPoints.C.x)/2, y: (currentPoints.B.y + currentPoints.C.y)/2 };
            ctx.beginPath(); ctx.moveTo(midAB.x, midAB.y); ctx.lineTo(midCD.x, midCD.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(midAD.x, midAD.y); ctx.lineTo(midBC.x, midBC.y); ctx.stroke();
        }

        function drawVisualEke(cornerLabel) {
            const p = currentPoints[cornerLabel];
            const size = 50;
            ctx.save();
            ctx.translate(p.x, p.y);
            
            // Xoay √™ke cho ƒë√∫ng g√≥c
            let rot = 0;
            if (cornerLabel === 'B') rot = -90;
            if (cornerLabel === 'C') rot = 180;
            if (cornerLabel === 'D') rot = 90;
            ctx.rotate(rot * Math.PI / 180);

            // V·∫Ω tam gi√°c
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(size, 0);
            ctx.lineTo(0, size);
            ctx.closePath();
            
            // Logic m√†u s·∫Øc: N·∫øu c·ª≠a x·ªá -> √äke ƒë·ªè (c·∫£nh b√°o), C·ª≠a vu√¥ng -> √äke v√†ng/xanh
            // ·ªû ƒë√¢y v·∫Ω √™ke chu·∫©n m√†u v√†ng, n·∫øu c·ª≠a x·ªá th√¨ n√≥ s·∫Ω b·ªã h·ªü ra (visual trick)
            
            ctx.fillStyle = 'rgba(255, 193, 7, 0.7)'; // V√†ng trong su·ªët
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.fill();
            ctx.stroke();

            // N·∫øu kh√¥ng vu√¥ng (ch·∫ø ƒë·ªô skew), v·∫Ω th√™m k√Ω hi·ªáu c·∫£nh b√°o nh·ªè
            if (isSkewed) {
                // Ch·ªâ minh h·ªça g√≥c A v√† C nh·ªçn, B v√† D t√π -> ƒë·ªÅu ko kh·ªõp
                 ctx.fillStyle = 'red';
                 ctx.font = '20px Arial';
                 ctx.textAlign = 'center';
                 ctx.fillText('!', size/3, size/3);
            }

            ctx.restore();
        }

        // --- X·ª¨ L√ù T∆Ø∆†NG T√ÅC ---
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // T√¨m ƒëi·ªÉm click
            let clickedLabel = null;
            for (let l in currentPoints) {
                const p = currentPoints[l];
                if (Math.hypot(p.x - x, p.y - y) < 25) {
                    clickedLabel = l; break;
                }
            }
            if (!clickedLabel) return;

            if (currentTool === 'eke') {
                // Th√™m v√†o danh s√°ch ƒë√£ ƒëo (n·∫øu ch∆∞a c√≥)
                if (!measuredCorners.includes(clickedLabel)) {
                    measuredCorners.push(clickedLabel);
                    
                    let msg = isSkewed ? `G√≥c ${clickedLabel}: KH√îNG vu√¥ng!` : `G√≥c ${clickedLabel}: Vu√¥ng.`;
                    let col = isSkewed ? 'red' : 'green';
                    log(msg, col);
                    
                    if (measuredCorners.length >= 3 && !isSkewed) {
                        showResult("success", "ƒê√£ ki·ªÉm tra 3 g√≥c vu√¥ng => H√åNH CH·ªÆ NH·∫¨T");
                    } else if (isSkewed) {
                        showResult("error", "C√°c g√≥c kh√¥ng kh·ªõp √äke => KH√îNG PH·∫¢I h√¨nh ch·ªØ nh·∫≠t");
                    }
                }
            } else {
                // Tool D√¢y
                if (selectedPoints.includes(clickedLabel)) return;
                selectedPoints.push(clickedLabel);
                
                if (selectedPoints.length === 2) {
                    // Ho√†n th√†nh 1 c·∫∑p
                    const [p1, p2] = selectedPoints;
                    const d1 = currentPoints[p1];
                    const d2 = currentPoints[p2];
                    const dist = Math.round(Math.hypot(d1.x - d2.x, d1.y - d2.y));
                    
                    // L∆∞u v√†o m·∫£ng
                    measuredLines.push({ p1, p2, dist });
                    log(`ƒêo·∫°n ${p1}${p2} = ${dist}`, '#6f42c1');
                    
                    // Ki·ªÉm tra k·∫øt qu·∫£
                    checkStringResult();
                    
                    selectedPoints = []; // Reset ch·ªçn ƒëi·ªÉm t·∫°m th·ªùi
                }
            }
            drawScene(); // V·∫Ω l·∫°i ƒë·ªÉ c·∫≠p nh·∫≠t thay ƒë·ªïi
        });

        function checkStringResult() {
            // T√¨m xem ƒë√£ ƒëo AC v√† BD ch∆∞a
            const ac = measuredLines.find(m => (m.p1+m.p2 === 'AC' || m.p1+m.p2 === 'CA'));
            const bd = measuredLines.find(m => (m.p1+m.p2 === 'BD' || m.p1+m.p2 === 'DB'));

            if (ac && bd) {
                if (ac.dist === bd.dist) {
                    showResult("success", `Hai ƒë∆∞·ªùng ch√©o b·∫±ng nhau (${ac.dist}) => H√åNH CH·ªÆ NH·∫¨T`);
                } else {
                    showResult("error", `Hai ƒë∆∞·ªùng ch√©o l·ªách nhau (${ac.dist} ‚â† ${bd.dist}) => C·ª¨A B·ªä X·ªÜ`);
                }
            }
        }

        function log(msg, color) {
            const div = document.createElement('div');
            div.className = 'log-item';
            div.style.color = color;
            div.textContent = msg;
            logEl.prepend(div);
        }

        function showResult(type, text) {
            finalResultEl.style.display = 'block';
            finalResultEl.textContent = text;
            if (type === 'success') {
                finalResultEl.style.background = '#d4edda';
                finalResultEl.style.color = '#155724';
            } else {
                finalResultEl.style.background = '#f8d7da';
                finalResultEl.style.color = '#721c24';
            }
        }

        // Ch·∫°y l·∫ßn ƒë·∫ßu
        drawScene();
    </script>
</body>
</html>
